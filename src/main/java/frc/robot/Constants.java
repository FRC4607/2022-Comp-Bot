// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot;

import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.math.trajectory.TrajectoryConfig;
import edu.wpi.first.math.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.PneumaticsModuleType;

/**
 * The Constants class provides a convenient place for teams to hold robot-wide
 * numerical or boolean
 * constants. This class should not be used for any other purpose. All constants
 * should be
 * declared globally (i.e. public static). Do not put anything functional in
 * this class.
 *
 * <p>
 * It is advised to statically import this class (or one of its inner classes)
 * wherever the
 * constants are needed, to reduce verbosity.
 */
public class Constants {
    /**
     * public static final class DriveConstants {
     * public static final int kLeftMotor1Port = 0;
     * public static final int kLeftMotor2Port = 1;
     * public static final int kRightMotor1Port = 2;
     * public static final int kRightMotor2Port = 3;
     * }
     */
    
    public static final class DriveConstants {
        public static final int leftMotor1ID = 0;
        public static final int leftMotor2ID = 1;
        public static final int rightMotor1ID = 3;
        public static final int rightMotor2ID = 4;
        public static final int leftEncoderID = 2;
        public static final int rightEncoderID = 5;
        public static final int pigeonID = 6;
        public static final int countsPerRevolution = 4096;
        public static final double sensorCoefficient = (Math.PI * Units.inchesToMeters(6)) / countsPerRevolution; // 0.478777
        public static final double ks_Volts = 0.58644; // [0.58644, 0.5908]
        public static final double kv_VoltSecondsPerMeters = 2.5377; // [2.5331, 2.5377]
        public static final double ka_VoltSecondsSquaredPerMeters = 0.25145; // [0.20049, 0.25145]
        public static final double trackWidth_Meters = Units.inchesToMeters(28); // Theoretical
        public static final DifferentialDriveKinematics kDriveKinematics = new DifferentialDriveKinematics(
            trackWidth_Meters);
            public static final double maxVoltage = 10;
            
            // PID drive
            public static final double kPDriveVel = 2.9445 * 1.2;
            
            public static final double maxSpeed = 1;
            public static final double maxTurning = 0.9;
            
            //Ramset
            public static final double kRamseteB_radSquaredPerMetersSquared = 2;
            public static final double kRamseteZeta_PerRad = 0.7;
        public static final double maxUnitsPerSecond = 2;
    }

    public static final class IntakeConstants {
        public static final int motorID = 7;
        public static final int solenoidModule = 8;
        public static final PneumaticsModuleType SolenoidType = PneumaticsModuleType.REVPH;
        public static final int solenoidForwardChannel = 0;
        public static final int solenoidReverseChannel = 1;

        public static final double intakeSpeed = 1;
        public static final double reverseScalar = 0.5;
    }

    public static final class TowerConstants {
        public static final int agitatiorID = 9;
        public static final double agitatiorSpeed = 1;

        public static final int midBrakeBeamID = 0;
        public static final int highBrakeBeamID = 1;
    }
    
    public static final class TransferWheelConstants {
        public static final int transferWheelID = 10;
        public static final double transferWheelSpeed = 1;
    }
    
    public static final class FlywheelConstants {
        public static final int flywheelMotor1ID = 11;
        public static final int flywheelMotor2ID = 12;

        // This is calculated from the characterization tool's CTRE preset.
        public static final double flywheelP = 0.17121;
        public static final double flywheelD = 0;

        /*
            0.17121, 0.0171
            0.17121, 0.02
            0.17121, 0.05
            0.25, 0.1
            0.15, 0.1
            0.15, 0.0
            Peck 1
                +320
                +310
                +300
                +500
                +290
        */
        // kS from characterization tool, used here as an arbitrary feed forward to overcome friction. This is divided by 12 to get the value as a percent of the motor's max output.
        public static final double flywheelKs = 0.64575 / 12;
        // kA from characterization tool, used here as the velocity feed forward. Conversion from v / (rotation/sec) to CTRE units (v (0-1023) / (rotations / 0.1sec) ) is needed.
        //public static final double flywheelKf = 0.05103092783505154639175257731959;
        public static final double flywheelKf = 0.046775;

        public static final int flywheeelRPM = 3800;

        public static final float flywheelMaxError = 200; // 50
    }
    
    public static final class FollowPathConstants {
        public static final double kMaxSpeed_MetersPerSecond = 3;
        public static final double kMaxAcceleration_MetersPerSecondSquared = 2;

        public static final DifferentialDriveVoltageConstraint voltageConstraint = new DifferentialDriveVoltageConstraint(
            new SimpleMotorFeedforward(DriveConstants.ks_Volts, DriveConstants.kv_VoltSecondsPerMeters,
            DriveConstants.ka_VoltSecondsSquaredPerMeters), DriveConstants.kDriveKinematics, DriveConstants.maxVoltage);

        public static final TrajectoryConfig trajectoryConfig = new TrajectoryConfig(FollowPathConstants.kMaxSpeed_MetersPerSecond, 
        FollowPathConstants.kMaxAcceleration_MetersPerSecondSquared)
        // Add kinematics to ensure max speed is actually obeyed
        .setKinematics(DriveConstants.kDriveKinematics)
        // Apply the voltage constraint
        .addConstraint(voltageConstraint);
    }

    

}
