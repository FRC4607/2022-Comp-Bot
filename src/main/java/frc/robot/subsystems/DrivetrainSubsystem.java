// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.DriveConstants;

import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.sensors.AbsoluteSensorRange;
import com.ctre.phoenix.sensors.CANCoder;
import com.ctre.phoenix.sensors.CANCoderConfiguration;
import com.ctre.phoenix.sensors.PigeonIMU;
import com.ctre.phoenix.sensors.SensorInitializationStrategy;
import com.ctre.phoenix.sensors.PigeonIMU.GeneralStatus;
import com.ctre.phoenix.sensors.PigeonIMU.PigeonState;

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DrivetrainSubsystem extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // _BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANCoder leftEncoder;
    private CANCoder rightEncoder;
    private WPI_TalonFX leftMotor1;
    private WPI_TalonFX leftMotor2;
    private MotorControllerGroup leftDrive;
    private WPI_TalonFX rightMotor1;
    private WPI_TalonFX rightMotor2;
    private MotorControllerGroup rightDrive;
    private DifferentialDrive drivetrain;
    // private ADIS16470_IMU ADISIMU;
    private final CANCoderConfiguration encoderConfig;
    private final TalonFXConfiguration motorConfig;
    private PigeonIMU pigeonIMU;
    private boolean pigeonFailure = false;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public DrivetrainSubsystem() {
        encoderConfig = new CANCoderConfiguration();
        encoderConfig.absoluteSensorRange = AbsoluteSensorRange.Unsigned_0_to_360;
        encoderConfig.initializationStrategy = SensorInitializationStrategy.BootToZero;
        encoderConfig.sensorCoefficient = DriveConstants.sensorCoefficient;
        encoderConfig.unitString = "m";

        // _BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftEncoder = new CANCoder(DriveConstants.leftEncoderID);
        leftEncoder.configFactoryDefault();
        leftEncoder.configAllSettings(encoderConfig);
        leftEncoder.configSensorDirection(true);

        rightEncoder = new CANCoder(DriveConstants.rightEncoderID);
        rightEncoder.configFactoryDefault();
        rightEncoder.configAllSettings(encoderConfig);

        motorConfig = new TalonFXConfiguration();
        motorConfig.supplyCurrLimit = new SupplyCurrentLimitConfiguration(true, 35, 40, 0.2);
        motorConfig.absoluteSensorRange = AbsoluteSensorRange.Unsigned_0_to_360;
        motorConfig.remoteFilter0.remoteSensorSource = RemoteSensorSource.CANCoder;
        motorConfig.remoteFilter0.remoteSensorDeviceID = leftEncoder.getDeviceID();
        motorConfig.remoteFilter1.remoteSensorSource = RemoteSensorSource.CANCoder;
        motorConfig.remoteFilter1.remoteSensorDeviceID = rightEncoder.getDeviceID();

        leftMotor1 = new WPI_TalonFX(DriveConstants.leftMotor1ID);
        leftMotor1.configFactoryDefault();
        leftMotor1.configAllSettings(motorConfig);
        leftMotor2 = new WPI_TalonFX(DriveConstants.leftMotor2ID);
        leftMotor2.configFactoryDefault();
        leftMotor2.configAllSettings(motorConfig);

        leftDrive = new MotorControllerGroup(leftMotor1, leftMotor2);
        addChild("LeftDrive", leftDrive);

        rightMotor1 = new WPI_TalonFX(DriveConstants.rightMotor1ID);
        rightMotor1.configFactoryDefault();
        rightMotor1.configAllSettings(motorConfig);
        rightMotor1.setInverted(true);
        rightMotor2 = new WPI_TalonFX(DriveConstants.rightMotor2ID);
        rightMotor2.configFactoryDefault();
        rightMotor2.configAllSettings(motorConfig);
        rightMotor2.setInverted(true);

        rightDrive = new MotorControllerGroup(rightMotor1, rightMotor2);
        addChild("RightDrive", rightDrive);

        drivetrain = new DifferentialDrive(leftDrive, rightDrive);
        // drivetrain = new DifferentialDrive(leftMotor2, rightMotor2);
        addChild("Drivetrain", drivetrain);

        drivetrain.setSafetyEnabled(true);
        drivetrain.setExpiration(0.1);
        drivetrain.setMaxOutput(1.0);

        // ADISIMU = new ADIS16470_IMU();
        pigeonIMU = new PigeonIMU(DriveConstants.pigeonID);

        pigeonIMU.setFusedHeading(0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void periodic() {
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Sets the voltage of the left side motors. Needs to be called continuously.
     * Will be overwritten by calls to setArcadeDrive!
     * 
     * @param voltage The voltage to set the left side of the drivtrain to.
     */
    public void setLeftVoltage(double voltage) {
        leftDrive.setVoltage(voltage);
    }

    /**
     * Sets the voltage of the right side motors. Needs to be called continuously.
     * Will be overwritten by calls to setArcadeDrive!
     * 
     * @param voltage The voltage to set the right side of the drivtrain to.
     */
    public void setRightVoltage(double voltage) {
        rightDrive.setVoltage(voltage);
    }

    /**
     * Sets the voltage of both the left and right side motors. Needs to be called
     * continuously. Will be overwritten by calls to setArcadeDrive!
     * 
     * @param voltage The voltage to set both sides of the drivetrain to.
     */
    public void setVoltage(double voltage) {
        leftDrive.setVoltage(voltage);
        rightDrive.setVoltage(voltage);
    }

    /**
     * Returns the left encoder absolute position.
     * 
     * @return The absolute position of the left encoder ranging from [0, Math.PI *
     *         Units.inchesToMeters(6)) in meters.
     */
    public double getLeftEncoderAbsolutePosition() {
        return leftEncoder.getAbsolutePosition();
    }

    /**
     * Returns the right encoder absolute position.
     * * @return The absolute position of the right encoder ranging from [0, Math.PI
     * * Units.inchesToMeters(6)) in meters.
     */
    public double getRightEncoderAbsolutePosition() {
        return rightEncoder.getAbsolutePosition();
    }

    /**
     * Returns the left encoder position.
     * 
     * @return The position of the right side of the drivetrain in meters.
     */
    public double getLeftEncoderPosition() {
        return leftEncoder.getPosition();
    }

    /**
     * Returns the right encoder position.
     * 
     * @return The position of the right side of the drivetrain in meters.
     */
    public double getRightEncoderPosition() {
        return rightEncoder.getPosition();
    }

    /**
     * Sets the position of the left encoder.
     * 
     * @param position The position of the left side of the drivetrain in meters.
     */
    public void setLeftEncoderPostion(double position) {
        leftEncoder.setPosition(position);
    }

    /**
     * Sets the position of the right encoder.
     * 
     * @param position The position of the right side of the drivetrain in meters.
     */
    public void setRightEncoderPostion(double position) {
        rightEncoder.setPosition(position);
    }

    /**
     * Sets the position of both the left and right side encoders at the same time.
     * 
     * @param position The position of the two sides of the drivetrain in meters.
     */
    public void setEncoderPostion(double position) {
        leftEncoder.setPosition(position);
        rightEncoder.setPosition(position);
    }

    /**
     * Allows the joystick to be used in a way people understand. Arcade style.
     * 
     * @param x The x-axis of the controller.
     * @param y The y-axis of the controller.
     */
    public void setArcadeDrive(double x, double y) {
        // The y is inverted so forward will be positive and backward will be negative.
        drivetrain.arcadeDrive(-y, x);

        // YAAY my first code!!! I did something useful! -Helen
    }

    /**
     * Check to see if our pigeon has disconnected. Useful for switching to a backup
     * IMU if present.
     * 
     * @return True if the pigeon has failed, false otherwise.
     */
    private boolean checkForPigeonFailure() {
        GeneralStatus status = new GeneralStatus();
        pigeonIMU.getGeneralStatus(status);
        if (status.state == PigeonState.NoComm || status.state == PigeonState.Unknown) {
            pigeonFailure = true;
            return true;
        } else {
            return false;
        }
    }

    /*
     * Quick note about Rotation2d from WPILib:
     * - It's based on radians, so all angles are internally stored as a x and y
     * coordinate on the unit circle, or cos and sin components respectively.
     * - Therefore, Rotation2d is CCW positive, just like the radian system.
     * - This also means you must be really careful to not pass in any degree
     * measures without converting them first.
     * - Rotation2d goes from -inf to inf, so you can use it continuously.
     */

    /**
     * Returns the robot's heading, ranging from -inf to inf, with counterclockwise
     * being positive.
     * 
     * @return The rotation of the robot in degrees, with counterclockwise rotations
     *         increasing this value.
     */
    public double getGyroscopeReadingContinuous() {
        return getGyroscopeReadingContinuous(true);
    }

    /**
     * Returns the robot's heading, ranging from -inf to inf.
     * 
     * @param ccwPositive Whether the reading should be returned treating
     *                    counterclockwise as positive or negative, with true
     *                    meaning ccw is positive.
     * @return The rotation of the robot in degrees.
     */
    public double getGyroscopeReadingContinuous(boolean ccwPositive) {
        if (!pigeonFailure && !checkForPigeonFailure()) {
            if (ccwPositive) {
                return pigeonIMU.getFusedHeading();
            } else {
                return -pigeonIMU.getFusedHeading();
            }
        } else {
            // Can't use these due to Analog Devices gyro bug.
            /*
             * double uncorrectedHeading = ADISIMU.getAngle();
             * if (ccwPositive) {
             * return uncorrectedHeading;
             * } else {
             * return -uncorrectedHeading;
             * }
             */
            return 0;
        }
    }

    /**
     * Returns the robot's heading, with a range of [-180, 180], with
     * counterclockwise being positive.
     * 
     * @return The rotation of the robot in degrees, with counterclockwise rotations
     *         increasing this value.
     */
    public double getGyroscopeReading() {
        return getGyroscopeReading(true);
    }

    /**
     * Returns the robot's heading, with a range of [-180, 180].
     * 
     * @param ccwPositive Whether the reading should be returned treating
     *                    counterclockwise as positive or negative, with true
     *                    meaning ccw is positive.
     * @return The rotation of the robot in degrees.
     */
    public double getGyroscopeReading(boolean ccwPositive) {
        double continuousHeading = getGyroscopeReadingContinuous(ccwPositive);

        /**
         * Corrects the values to the range of [-180, 180]
         * 
         * First the value is caped to [-360, 360],
         * than if the value is outside of [-180, 180]
         * 360 is added or subtracted as nesasary to get within the desiered range
         */
        double correctedValue = continuousHeading % 360;

        if (correctedValue > 180) {
            return correctedValue - 360;
        } else if (correctedValue < -180) {
            return correctedValue + 360;
        } else {
            return correctedValue;
        }
    }

    // Can't use these due to Analog Devices gyro bug.
    /**
     * Gets the x acceleration of the robot in m/s^2 (i think). You can check which
     * axis is which direction and sign by looking at the graphic on the roborio.
     * 
     * @return The acceleration on the x axis.
     *         public double getXAccel() {
     *         return ADISIMU.getAccelX();
     *         }
     * 
     *         /**
     *         Gets the y acceleration of the robot in m/s^2 (i think). You can
     *         check which
     *         axis is which direction and sign by looking at the graphic on the
     *         roborio.
     * 
     * @return The acceleration on the y axis.
     *         public double getYAccel() {
     *         return ADISIMU.getAccelY();
     *         }
     * 
     *         /**
     *         Gets the z acceleration of the robot in m/s^2 (i think). You can
     *         check which
     *         axis is which direction and sign by looking at the graphic on the
     *         roborio.
     * 
     * @return The acceleration on the z axis.
     *         public double getZAccel() {
     *         return ADISIMU.getAccelZ();
     *         }
     */
}
